// Generated by CoffeeScript 1.3.3
(function() {
  var Future, extend, http, https, method, querystring, request, url, _i, _len, _ref,
    __slice = [].slice;

  Future = require('fibers/future');

  http = require('http');

  https = require('https');

  url = require('url');

  querystring = require('querystring');

  extend = function() {
    var dest, key, s, sources, val, _i, _len;
    dest = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      s = sources[_i];
      for (key in s) {
        val = s[key];
        dest[key] = val;
      }
    }
    return dest;
  };

  exports.request = request = function(options) {
    var f, parsed, path, protocol, qs, query, req, requestBody, timeout, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    f = new Future;
    options = extend({}, options);
    if (timeout = options.timeout) {
      delete options.timeout;
    }
    if (requestBody = options.body) {
      delete options.body;
    }
    if (options.url) {
      parsed = url.parse(options.url);
      options = extend({
        hostname: parsed.hostname,
        port: parsed.port || 80,
        protocol: parsed.protocol,
        path: parsed.path
      }, options);
      delete options.url;
    }
    if (options.query) {
      _ref = (options.path || '').split('?'), path = _ref[0], query = _ref[1];
      query = querystring.parse(query);
      qs = querystring.stringify(extend(query, options.query));
      if (qs.length > 0) {
        options.path = (path || '') + '?' + qs;
      }
      delete options.query;
    }
    protocol = ((_ref1 = options.protocol) != null ? _ref1.match(/^https/) : void 0) ? https : http;
    req = protocol.request(options);
    if (timeout) {
      req.setTimeout(timeout, function() {
        req.end();
        if (!f.isResolved()) {
          return f["throw"](new Error("Http Timeout"));
        }
      });
    }
    req.on('error', function(err) {
      if (!f.isResolved()) {
        return f["throw"](err);
      }
    });
    req.on('response', function(res) {
      var body;
      body = '';
      res.on('close', function(err) {
        if (!f.isResolved()) {
          return f["throw"](err);
        }
      });
      res.on('error', function(err) {
        if (!f.isResolved()) {
          return f["throw"](err);
        }
      });
      res.on('data', function(data) {
        return body += data;
      });
      return res.on('end', function() {
        if (!f.isResolved()) {
          return f["return"]({
            body: body,
            headers: res.headers,
            trailers: res.trailers,
            statusCode: res.statusCode,
            httpVersion: res.httpVresion
          });
        }
      });
    });
    if (requestBody) {
      req.write(requestBody);
    }
    req.end();
    return f.wait();
  };

  _ref = ['put', 'post', 'delete'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    method = _ref[_i];
    exports[method] = (function(method) {
      return function(body, options) {
        return request(extend({}, {
          body: body,
          method: method.toUpperCase()
        }, options));
      };
    })(method);
  }

  exports.get = function(options) {
    return request(extend({}, {
      method: 'GET'
    }, options));
  };

}).call(this);
