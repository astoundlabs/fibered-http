// Generated by CoffeeScript 1.3.3
(function() {
  var Future, Request, extend, http, https, method, querystring, request, url, _i, _len, _ref,
    __slice = [].slice;

  Future = require('fibers/future');

  http = require('http');

  https = require('https');

  url = require('url');

  querystring = require('querystring');

  extend = function() {
    var dest, key, s, sources, val, _i, _len;
    dest = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      s = sources[_i];
      for (key in s) {
        val = s[key];
        dest[key] = val;
      }
    }
    return dest;
  };

  Request = (function() {

    function Request(options) {
      var defaults, parsed, path, qs, query, _ref;
      defaults = {
        maxRedirects: 10,
        followRedirects: true
      };
      this.options = extend({}, defaults, options);
      if (this.options.url) {
        parsed = url.parse(this.options.url);
        this.options = extend({
          hostname: parsed.hostname,
          port: parsed.port || 80,
          protocol: parsed.protocol,
          path: parsed.path
        }, this.options);
        delete this.options.url;
      }
      if (this.options.query) {
        _ref = (this.options.path || '').split('?'), path = _ref[0], query = _ref[1];
        query = querystring.parse(query);
        qs = querystring.stringify(extend(query, this.options.query));
        if (qs.length > 0) {
          this.options.path = (path || '') + '?' + qs;
        }
        delete this.options.query;
      }
    }

    Request.prototype.send = function() {
      var future, protocol, req, _ref,
        _this = this;
      future = new Future;
      protocol = ((_ref = this.options.protocol) != null ? _ref.match(/^https/) : void 0) ? https : http;
      req = protocol.request(this.options);
      if (this.options.timeout) {
        req.setTimeout(this.options.timeout, function() {
          req.end();
          if (!future.isResolved()) {
            return future["throw"](new Error("Http Timeout"));
          }
        });
      }
      req.on('error', function(err) {
        if (!future.isResolved()) {
          return future["throw"](err);
        }
      });
      req.on('response', function(res) {
        return _this.response(res, future);
      });
      if (this.options.requestBody) {
        req.write(this.options.requestBody);
      }
      req.end();
      return future.wait();
    };

    Request.prototype.response = function(res, future) {
      var body;
      if (Math.floor(res.statusCode / 100) === 3 && this.options.followRedirects && this.options.maxRedirects > 0) {
        return this.redirect(res.headers.Location || res.headers.location, future);
      } else {
        body = '';
        res.on('close', function(err) {
          if (!future.isResolved()) {
            return future["throw"](err);
          }
        });
        res.on('error', function(err) {
          if (!future.isResolved()) {
            return future["throw"](err);
          }
        });
        res.on('data', function(data) {
          return body += data;
        });
        return res.on('end', function() {
          if (!future.isResolved()) {
            return future["return"]({
              body: body,
              headers: res.headers,
              trailers: res.trailers,
              statusCode: res.statusCode,
              httpVersion: res.httpVresion
            });
          }
        });
      }
    };

    Request.prototype.redirect = function(location, future) {
      var _this = this;
      if (Fiber.current) {
        return future["return"](new Request(extend(this.options, {
          maxRedirects: this.options.maxRedirects - 1
        })).send());
      } else {
        return Fiber(function() {
          return _this.redirect(location, future);
        }).run();
      }
    };

    return Request;

  })();

  exports.request = request = function(options) {
    return new Request(options).send();
  };

  _ref = ['put', 'post', 'delete'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    method = _ref[_i];
    exports[method] = (function(method) {
      return function(body, options) {
        return request(extend({}, {
          body: body,
          method: method.toUpperCase()
        }, options));
      };
    })(method);
  }

  exports.get = function(options) {
    return request(extend({}, {
      method: 'GET'
    }, options));
  };

}).call(this);
